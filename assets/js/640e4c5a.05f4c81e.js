"use strict";(self.webpackChunkelasticstack_notes=self.webpackChunkelasticstack_notes||[]).push([[4785],{2495:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>o});var t=i(4848),r=i(8453);const s={sidebar_position:5},a="Federation from Day One",l={id:"tutorial/Federation",title:"Federation from Day One",description:"Intro to Federation",source:"@site/docs/tutorial/Federation.md",sourceDirName:"tutorial",slug:"/tutorial/Federation",permalink:"/apollo-graphql-notes/docs/tutorial/Federation",draft:!1,unlisted:!1,editUrl:"https://github.com/devkobetran/apollo-graphql-notes/docs/tutorial/Federation.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Mutations",permalink:"/apollo-graphql-notes/docs/tutorial/Mutations"},next:{title:"Federating the Monolith",permalink:"/apollo-graphql-notes/docs/tutorial/Monolith"}},h={},o=[{value:"Intro to Federation",id:"intro-to-federation",level:2},{value:"Overview",id:"overview",level:3},{value:"Life before Apollo Federation",id:"life-before-apollo-federation",level:3},{value:"The structure of a supergraph",id:"the-structure-of-a-supergraph",level:3},{value:"Subgraphs",id:"subgraphs",level:3},{value:"The router",id:"the-router",level:3},{value:"Why use Apollo Federation?",id:"why-use-apollo-federation",level:3},{value:"Project setup",id:"project-setup",level:2},{value:"Agreeing on a schema",id:"agreeing-on-a-schema",level:2},{value:"Practice",id:"practice",level:4},{value:"Building out the subgraphs",id:"building-out-the-subgraphs",level:2},{value:"Practice",id:"practice-1",level:4},{value:"Managed Federation &amp; the supergraph",id:"managed-federation--the-supergraph",level:2},{value:"Managed Federation process",id:"managed-federation-process",level:4},{value:"Publishing the Subgraphs with Rover",id:"publishing-the-subgraphs-with-rover",level:2},{value:"Supergraph",id:"supergraph",level:4},{value:"How the Router resolves data",id:"how-the-router-resolves-data",level:2},{value:"Router configuration and Uplink",id:"router-configuration-and-uplink",level:2},{value:"What information does the Query Plan Preview in GraphOS Studio include?",id:"what-information-does-the-query-plan-preview-in-graphos-studio-include",level:4},{value:"Connecting data using entities",id:"connecting-data-using-entities",level:2},{value:"What&#39;s an entity?",id:"whats-an-entity",level:3},{value:"Reference the entity",id:"reference-the-entity",level:3},{value:"Contribute fields to the entity",id:"contribute-fields-to-the-entity",level:3},{value:"How to create an entity",id:"how-to-create-an-entity",level:3},{value:"What&#39;s an entity representation?",id:"whats-an-entity-representation",level:4},{value:"Practice",id:"practice-2",level:4},{value:"Defining an entity",id:"defining-an-entity",level:2},{value:"Entities &amp; The Query Plan",id:"entities--the-query-plan",level:2},{value:"Practice",id:"practice-3",level:4},{value:"Referencing Entity",id:"referencing-entity",level:2},{value:"Practice",id:"practice-4",level:4},{value:"Contributing to an Entity",id:"contributing-to-an-entity",level:2},{value:"Practice",id:"practice-5",level:4},{value:"Code Challenge",id:"code-challenge",level:4},{value:"Putting it all together",id:"putting-it-all-together",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"federation-from-day-one",children:"Federation from Day One"})}),"\n",(0,t.jsx)(n.h2,{id:"intro-to-federation",children:"Intro to Federation"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/01-intro-to-federation",children:"Intro to Federation"})}),"\n",(0,t.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Apollo Federation"})," is an architecture for creating modular graphs.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Your graph is built in smaller pieces that all work together."}),"\n",(0,t.jsx)(n.li,{children:"The supergraph improves the developer experience for teams, making it easier to scale your product."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"life-before-apollo-federation",children:"Life before Apollo Federation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'"supergraph" and "federated graph" mean the same thing: your graph\'s functionality is divided across smaller, modular graphs.'}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"the-structure-of-a-supergraph",children:"The structure of a supergraph"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A supergraph has two key pieces:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"One or more subgraphs"}),"\n",(0,t.jsx)(n.li,{children:"A router"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"subgraphs",children:"Subgraphs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In a supergraph, your schema is built in smaller parts.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each part of the schema is owned by a separate subgraph."}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"subgraph"})," is a standalone GraphQL server with its own schema file, resolvers, and data sources."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"the-router",children:"The router"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A supergraph architecture also includes the ",(0,t.jsx)(n.strong,{children:"router"}),", which sits between clients and the subgraphs.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The router is responsible for accepting incoming operations from clients and splitting them into smaller operations that can each be resolved by a single subgraph."}),"\n",(0,t.jsx)(n.li,{children:"The router does this work with the help of the supergraph schema."}),"\n",(0,t.jsx)(n.li,{children:"The supergraph schema is composed of all the fields and types from each subgraph schema."}),"\n",(0,t.jsx)(n.li,{children:"The supergraph schema is a bit like a map, helping the router determine which subgraph can resolve each field in an operation."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"why-use-apollo-federation",children:"Why use Apollo Federation?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Core principles of ",(0,t.jsx)(n.strong,{children:"Apollo Federation"}),": the separation of concerns."]}),"\n",(0,t.jsxs)(n.li,{children:["By splitting up our schema into subgraphs, backend teams can work on their own subgraphs independently, without impacting developers working on other subgraphs.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"And since each subgraph is a separate server, teams have the flexibility to choose the language, infrastructure, and policies that work best for them."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.p,{children:"Benefits of Apollo Federation:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A smoother developer experience among teams, because there are clearer boundaries of responsibility for different parts of the graph."}),"\n",(0,t.jsx)(n.li,{children:"Flexibility in subgraph configuration, which means subgraphs can have different numbers of instances, security protocols, or caching strategies."}),"\n"]})]}),"\n",(0,t.jsx)(n.h2,{id:"project-setup",children:"Project setup"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/02-project-setup",children:"Project setup"})}),"\n",(0,t.jsx)(n.h2,{id:"agreeing-on-a-schema",children:"Agreeing on a schema"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/03-agreeing-on-a-schema",children:"Agreeing on a schema"})}),"\n",(0,t.jsx)(n.h4,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.p,{children:"Subgraph Schemas:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Subgraph schemas help divide a graph's surface area according to different concerns."}),"\n",(0,t.jsx)(n.li,{children:"To decide how to split your schema into multiple subgraphs, you can group types and fields related to similar concerns."}),"\n",(0,t.jsx)(n.li,{children:"A subgraph schema should contain the types and fields it is responsible for populating."}),"\n"]})]}),"\n",(0,t.jsx)(n.h2,{id:"building-out-the-subgraphs",children:"Building out the subgraphs"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/04-building-out-the-subgraphs",children:"Building out the subgraphs"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"buildSubgraphSchema"})," function takes an object containing ",(0,t.jsx)(n.code,{children:"typeDefs"})," and ",(0,t.jsx)(n.code,{children:"resolvers"})," and returns a federation-ready subgraph schema."]}),"\n",(0,t.jsx)(n.li,{children:"This schema includes a number of federation directives and types that enable our subgraph to take full advantage of the power of federation."}),"\n"]})}),"\n",(0,t.jsx)(n.h4,{id:"practice-1",children:"Practice"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To make an ",(0,t.jsx)(n.code,{children:"ApolloServer"})," instance a subgraph, we install a package called ",(0,t.jsx)(n.code,{children:"@apollo/subgraph"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["From that package, we use a function called ",(0,t.jsx)(n.code,{children:"buildSubgraphSchema"}),", which accepts an object containing ",(0,t.jsx)(n.code,{children:"typeDefs"})," and ",(0,t.jsx)(n.code,{children:"resolvers"}),", and returns a federation-ready subgraph schema."]}),"\n",(0,t.jsxs)(n.li,{children:["We add this to the ",(0,t.jsx)(n.code,{children:"ApolloServer"})," configuration object using the ",(0,t.jsx)(n.code,{children:"schema"})," property."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"managed-federation--the-supergraph",children:"Managed Federation & the supergraph"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/05-managed-federation-and-the-supergraph",children:"Managed Federation & the supergraph"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When the schema registry gets a new or updated version of a subgraph schema, it starts a process called ",(0,t.jsx)(n.strong,{children:"composition"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"The schema registry attempts to combine all of the schemas from the registered subgraphs into a single supergraph schema."}),"\n",(0,t.jsx)(n.li,{children:"If composition succeeds and there are no validation errors, the schema registry produces a supergraph schema."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"managed-federation-process",children:"Managed Federation process"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Every supergraph includes 1 or more subgraphs, each of which has its own schema."}),"\n",(0,t.jsx)(n.li,{children:"With managed federation, each of these schemas is published to the Apollo schema registry."}),"\n",(0,t.jsx)(n.li,{children:"Whenever a subgraph schema is published, the schema registry triggers a process called composition."}),"\n",(0,t.jsx)(n.li,{children:"If successful, this process results in the creation of a supergraph schema, which is then fetched by the supergraph's router via periodic polling."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"After creating or updating a subgraph schema, developers use the Rover CLI to publish the subgraph schema to the Apollo schema registry."}),"\n",(0,t.jsx)(n.li,{children:"The Apollo schema registry composes the subgraph schemas into a supergraph schema, which the router uses to resolve incoming client requests."}),"\n",(0,t.jsx)(n.li,{children:"With managed federation, schema updates to the router are managed by GraphOS and happen with zero downtime."}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"publishing-the-subgraphs-with-rover",children:"Publishing the Subgraphs with Rover"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/06-publishing-the-subgraphs-with-rover",children:"Publishing the Subgraphs with Rover"})}),"\n",(0,t.jsx)(n.h4,{id:"supergraph",children:"Supergraph"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The supergraph can be generated automatically by registering subgraphs in GraphOS."}),"\n",(0,t.jsx)(n.li,{children:"The supergraph is the result of composing multiple subgraphs together."}),"\n",(0,t.jsx)(n.li,{children:"The supergraph is used by a router to resolve incoming client requests."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We can use the ",(0,t.jsx)(n.code,{children:"rover subgraph publish"})," command from the Rover CLI to publish our subgraph schemas to the Apollo schema registry."]}),"\n",(0,t.jsx)(n.li,{children:"Whenever a new subgraph schema is published, GraphOS composes a new supergraph schema with any subgraphs registered to our supergraph."}),"\n",(0,t.jsx)(n.li,{children:"The supergraph schema consolidates all the types and fields across our published subgraphs. It also includes extra directives to help the router determine which subgraphs can resolve each field."}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"how-the-router-resolves-data",children:"How the Router resolves data"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/07-how-the-router-resolves-data",children:"How the Router resolves data"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"The router uses the supergraph schema to resolve incoming GraphQL operations from the client"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Client sends a query"}),"\n",(0,t.jsx)(n.li,{children:"Router checks query against supergraph schema"}),"\n",(0,t.jsxs)(n.li,{children:["Router builds a ",(0,t.jsx)(n.strong,{children:"query plan"}),": a list of smaller GraphQL operations to execute on the subgraphs."]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The query plan also specifies the order in which the subgraph operations need to run."}),"\n",(0,t.jsx)(n.li,{children:"Query plan execution: each subgraph resolve their respective fields by using their resolvers and data sources to retrieve and populate the requested data."}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsx)(n.li,{children:"Subgraphs respond with data and the router combines it all into a single response object"}),"\n",(0,t.jsx)(n.li,{children:"Router collects subgraphs data to build the complete response and sends it back to client"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"router-configuration-and-uplink",children:"Router configuration and Uplink"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/08-router-configuration-and-uplink",children:"Router configuration and Uplink"})}),"\n",(0,t.jsx)(n.h4,{id:"what-information-does-the-query-plan-preview-in-graphos-studio-include",children:"What information does the Query Plan Preview in GraphOS Studio include?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It shows how the router will resolve an operation by requesting data from subgraphs."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The GraphOS Router is an executable binary file that can be downloaded and run locally."}),"\n",(0,t.jsx)(n.li,{children:"The Query Plan Preview inspects the GraphQL operation in the Explorer and outputs the query plan the router will execute to resolve the operation."}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"connecting-data-using-entities",children:"Connecting data using entities"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/09-connecting-data-using-entities",children:"Connecting data using entities"})}),"\n",(0,t.jsx)(n.h3,{id:"whats-an-entity",children:"What's an entity?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["An ",(0,t.jsx)(n.strong,{children:"entity"})," is an object type with fields split between multiple subgraphs."]}),"\n",(0,t.jsxs)(n.li,{children:["A subgraph that defines an entity can do one or both of the following:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Reference the entity"}),"\n",(0,t.jsx)(n.li,{children:"Contribute fields to the entity"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"reference-the-entity",children:"Reference the entity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Referencing an entity means using it as a return type for another field defined in the subgraph."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"contribute-fields-to-the-entity",children:"Contribute fields to the entity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Contributing fields to an entity means that one subgraph adds new fields to an entity that are specific to that subgraph's concerns."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"how-to-create-an-entity",children:"How to create an entity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"To convert an object into an entity in the subgraph schema, need to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Define a ",(0,t.jsx)(n.strong,{children:"primary key"}),", is the field (or fields) of an entity that can uniquely identify an instance of that entity within a subgraph."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The router uses primary keys to collect data from across multiple subgraphs and associate it with a single entity instance."}),"\n",(0,t.jsxs)(n.li,{children:["In each of our subgraph schemas, we can define a primary key for an entity, by adding the ",(0,t.jsx)(n.code,{children:"@key"})," directive after the type's name."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"@key"})," directive needs a property called ",(0,t.jsx)(n.code,{children:"fields"}),", which we'll set to the field we want to use as the entity's primary key."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"An entity can have more than 1 primary key."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'type EntityType @key(fields: "id") {\n  id: ID!\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Define a ",(0,t.jsx)(n.strong,{children:"reference resolver"}),", which is a special resolver function for an entity when each subgraph contributes fields to an entity."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The router uses reference resolvers to directly access the entity fields that each subgraph contributes."}),"\n",(0,t.jsxs)(n.li,{children:["Every reference resolver has the name: ",(0,t.jsx)(n.code,{children:"__resolveReference"}),", taking only 3 arguments:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"reference"}),": The entity representation object that's passed in by the router. This tells the subgraph which instance of an entity is being requested."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"context"}),": The object shared across all resolvers."]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(this is the same thing like ",(0,t.jsx)(n.code,{children:"contextValue"})," as in other resolvers!)"]}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"info"}),": Contains information about the operation's execution state, just like in a normal resolver."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"whats-an-entity-representation",children:"What's an entity representation?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["An ",(0,t.jsx)(n.strong,{children:"entity representation"})," is an object that the router uses to represent a specific instance of an entity."]}),"\n",(0,t.jsxs)(n.li,{children:["A representation always includes the ",(0,t.jsx)(n.strong,{children:"typename"})," for that entity and the ",(0,t.jsx)(n.code,{children:"@key"})," field for the specific instance.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"__typename"})," field: This field exists on all GraphQL types automatically. It always returns the name of its containing type, as a string.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["e.g. ",(0,t.jsx)(n.code,{children:"Location.__typename"}),' returns "Location".']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"@key"})," field: The key-value pair that a subgraph can use to identify the instance of an entity."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Entity Representation Example:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'{\n  "__typename": "Location",\n  "id": "loc-2"\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Analogy: You can think of an entity representation as a passport that the router uses to refer to a particular object between subgraphs.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The typename field is like a passport's country of origin. It says which entity the object belongs to."}),"\n",(0,t.jsxs)(n.li,{children:["And the ",(0,t.jsx)(n.code,{children:"@key"})," field is like a passport's ID number, uniquely identifying this instance of that entity."]}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,t.jsx)(n.h4,{id:"practice-2",children:"Practice"}),"\n",(0,t.jsxs)(n.p,{children:["Where should an entity's ",(0,t.jsx)(n.code,{children:"__resolveReference"})," function be defined?"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In each subgraph that contributes fields to the entity."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"defining-an-entity",children:"Defining an entity"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/10-defining-an-entity",children:"Defining an entity"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"stub"})," serves as a basic representation of a type that includes just enough information to work with that type in the subgraph."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To create an entity, we can use the ",(0,t.jsx)(n.code,{children:"@key"})," directive to specify which field(s) can uniquely identify an object of that type."]}),"\n",(0,t.jsxs)(n.li,{children:["When a subgraph can't be used to resolve any non-",(0,t.jsx)(n.code,{children:"@key"})," fields of an entity, we pass ",(0,t.jsx)(n.code,{children:"resolvable: false"})," to the ",(0,t.jsx)(n.code,{children:"@key"})," directive definition."]}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"entities--the-query-plan",children:"Entities & The Query Plan"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/11-entities-and-the-query-plan",children:"Entities & The Query Plan"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The router begins by building a ",(0,t.jsx)(n.strong,{children:"query plan"})," that indicates which requests to send to which subgraphs."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"practice-3",children:"Practice"}),"\n",(0,t.jsx)(n.p,{children:"Which of the following steps do NOT occur as part of how the router builds and executes its query plan?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The router makes individual requests to each subgraph and returns separate JSON objects."}),"\n",(0,t.jsxs)(n.li,{children:["The router makes a separate request to find out the ",(0,t.jsx)(n.strong,{children:"__typename"})," for each type included in the query."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When the router needs to query for fields from a different subgraph, it also asks for entity representations from the current subgraph it's querying. These representations will be used in the subsequent operation's ",(0,t.jsx)(n.code,{children:"\\_entities"})," field, set as the value for the ",(0,t.jsx)(n.code,{children:"representations"})," argument."]}),"\n",(0,t.jsx)(n.li,{children:"The reference resolver takes each representation and returns the matching data for its requested fields."}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"referencing-entity",children:"Referencing Entity"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/12-referencing-an-entity",children:"Referencing Entity"})}),"\n",(0,t.jsx)(n.h4,{id:"practice-4",children:"Practice"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When a subgraph references an entity as a return value, it provides a representation of that entity for the router to use. Which of the following are included in that representation?","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The entity's ",(0,t.jsx)(n.code,{children:"__typename"})]}),"\n",(0,t.jsxs)(n.li,{children:["The entity's ",(0,t.jsx)(n.code,{children:"@key"})," fields"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Which of the below is NOT one of the parameters accepted by the ",(0,t.jsx)(n.code,{children:"__resolveReference"})," function?","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"args"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"We can reference an entity in one subgraph as the return value for a type's field."}),"\n",(0,t.jsxs)(n.li,{children:["Any subgraph that contributes fields to an entity needs to define a ",(0,t.jsx)(n.code,{children:"__resolveReference"})," resolver function for that entity. This resolver is called when the router needs to resolve references to that entity made from within other subgraphs."]}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"contributing-to-an-entity",children:"Contributing to an Entity"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/13-contributing-to-an-entity",children:"Contributing to an Entity"})}),"\n",(0,t.jsx)(n.h4,{id:"practice-5",children:"Practice"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In a federated graph, we should define our subgraphs based on concerns instead of types."}),"\n",(0,t.jsx)(n.li,{children:"Types containing fields that can be resolved across multiple subgraphs are called entities."}),"\n",(0,t.jsx)(n.li,{children:"These types always have a key field that enables different subgraphs to associate data with the same object."}),"\n",(0,t.jsx)(n.li,{children:"To keep its supergraph schema up to date, our router can poll the Uplink."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"code-challenge",children:"Code Challenge"}),"\n",(0,t.jsxs)(n.p,{children:["You're working on a federated graph that manages book information. The ",(0,t.jsx)(n.code,{children:"authors"})," subgraph defines an ",(0,t.jsx)(n.code,{children:"Author"})," entity with a primary key field ",(0,t.jsx)(n.code,{children:"id"})," of non-nullable type ",(0,t.jsx)(n.code,{children:"ID"}),". You want to use the ",(0,t.jsx)(n.code,{children:"Author"})," entity in the ",(0,t.jsx)(n.code,{children:"books"})," subgraph. Define the ",(0,t.jsx)(n.code,{children:"Author"})," entity below, and add a new field, ",(0,t.jsx)(n.code,{children:"books"}),", which returns a non-nullable list of non-nullable type ",(0,t.jsx)(n.code,{children:"Book"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'  # Write your code here!\n  type Author @key(fields: "id"){\n      id: ID!\n      books: [Book!]!\n  }\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A subgraph that contributes fields to an entity should define the following:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The entity, using the ",(0,t.jsx)(n.code,{children:"@key"})," directive and its primary key fields, as well as the new fields the subgraph defines"]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"__resolveReference"})," function to know which particular entity instance a subgraph is resolving fields for. This can be taken care of by default by Apollo Server."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"A federated architecture helps organize and illustrate the relationships between types across our graph in a way that an app developer (or multiple teams of developers!) would want to consume the data."}),"\n",(0,t.jsx)(n.li,{children:"When both subgraphs use the same primary key to associate data for a type, the router coordinates data from both sources and bundles it up in a single response."}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part1/14-putting-it-all-together",children:"Putting it all together"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Clients request data from a single GraphQL server: the router."}),"\n",(0,t.jsx)(n.li,{children:"The router can set CORS rules to specify which websites can talk to it."}),"\n",(0,t.jsx)(n.li,{children:"We can set up these rules (and other configurations) through the router's config file."}),"\n"]})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);