"use strict";(self.webpackChunkelasticstack_notes=self.webpackChunkelasticstack_notes||[]).push([[1899],{7566:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>a});var t=i(4848),r=i(8453);const s={sidebar_position:6},o="Federating the Monolith",l={id:"tutorial/Monolith",title:"Federating the Monolith",description:"Airlock, the Monolith",source:"@site/docs/tutorial/Monolith.md",sourceDirName:"tutorial",slug:"/tutorial/Monolith",permalink:"/apollo-graphql-notes/docs/tutorial/Monolith",draft:!1,unlisted:!1,editUrl:"https://github.com/devkobetran/apollo-graphql-notes/docs/tutorial/Monolith.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Federation from Day One",permalink:"/apollo-graphql-notes/docs/tutorial/Federation"},next:{title:"Federation in Production",permalink:"/apollo-graphql-notes/docs/tutorial/Production"}},h={},a=[{value:"Airlock, the Monolith",id:"airlock-the-monolith",level:2},{value:"Practice",id:"practice",level:4},{value:"Monolith graph setup",id:"monolith-graph-setup",level:2},{value:"Monolith as a subgraph",id:"monolith-as-a-subgraph",level:2},{value:"Practice",id:"practice-1",level:4},{value:"Auth in a supergraph",id:"auth-in-a-supergraph",level:2},{value:"Authenticating the user",id:"authenticating-the-user",level:3},{value:"Sending HTTP headers to subgraphs",id:"sending-http-headers-to-subgraphs",level:3},{value:"Over to the subgraph",id:"over-to-the-subgraph",level:3},{value:"Back to the Router",id:"back-to-the-router",level:3},{value:"Practice",id:"practice-2",level:4},{value:"Configuring the router",id:"configuring-the-router",level:2},{value:"Practice",id:"practice-3",level:4},{value:"Subgraph planning",id:"subgraph-planning",level:2},{value:"Planning and preparation",id:"planning-and-preparation",level:3},{value:"Which of the following types should be marked as an entity in the schema?",id:"which-of-the-following-types-should-be-marked-as-an-entity-in-the-schema",level:4},{value:"Define entities",id:"define-entities",level:2},{value:"A Stub subgraph",id:"a-stub-subgraph",level:2},{value:"Practice",id:"practice-4",level:4},{value:"Using <code>@override</code> to migrate fields",id:"using-override-to-migrate-fields",level:2},{value:"The <code>@override</code> directive",id:"the-override-directive",level:3},{value:"Incremental migration with progressive <code>@override</code>",id:"incremental-migration-with-progressive-override",level:3},{value:"Practice",id:"practice-5",level:4},{value:"Implementing resolvers",id:"implementing-resolvers",level:2},{value:"Code Challenge",id:"code-challenge",level:4},{value:"Finishing up the subgraph",id:"finishing-up-the-subgraph",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"federating-the-monolith",children:"Federating the Monolith"})}),"\n",(0,t.jsx)(n.h2,{id:"airlock-the-monolith",children:"Airlock, the Monolith"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/01-airlock-the-monolith",children:"Airlock, the Monolith"})}),"\n",(0,t.jsx)(n.h4,{id:"practice",children:"Practice"}),"\n",(0,t.jsx)(n.p,{children:"Which of these are common problems that developers experience with a monolithic GraphQL schema?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Merge conflicts caused by modifying the same schema file as multiple other individuals and teams."}),"\n",(0,t.jsx)(n.li,{children:"Lack of focus on domain responsibilities caused by the presence of unrelated types and fields."}),"\n",(0,t.jsx)(n.li,{children:"Difficulty navigating to the information they need in a constantly growing schema file."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A simple schema can potentially evolve into a big, intimidating schema that is difficult to navigate and work with for different teams."}),"\n",(0,t.jsx)(n.li,{children:"Federation solves these problems, but the process will be different when starting with an existing application compared to a greenfield app."}),"\n",(0,t.jsx)(n.li,{children:"We want to avoid any issues with the client by following a migration plan that swaps the original monolith server with the router."}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"monolith-graph-setup",children:"Monolith graph setup"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/02-monolith-graph-setup",children:"Monolith graph setup"})}),"\n",(0,t.jsx)(n.h2,{id:"monolith-as-a-subgraph",children:"Monolith as a subgraph"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/03-monolith-as-a-subgraph",children:"Monolith as a subgraph"})}),"\n",(0,t.jsx)(n.h4,{id:"practice-1",children:"Practice"}),"\n",(0,t.jsx)(n.p,{children:"Which of these does the migration plan enable us to do when converting the monolith into a supergraph?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It preserves all of the schema's current types, fields, and features."}),"\n",(0,t.jsx)(n.li,{children:"It ensures that nothing changes about how the client makes requests."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"auth-in-a-supergraph",children:"Auth in a supergraph"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/04-auth-in-a-supergraph",children:"Auth in a supergraph"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Authentication"})," is determining whether a given user is logged in, and subsequently determining which user someone is."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Authorization"})," is determining what a given user has permission to do or see. (They're allowed to do what they're trying to do.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Field-level authorization"}),": each resolver checks whether the logged-in user has permission to access that part of the graph."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"authenticating-the-user",children:"Authenticating the user"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Query sent with Authorization headers"}),"\n",(0,t.jsx)(n.li,{children:"Router receives this request and builds a query plan."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"sending-http-headers-to-subgraphs",children:"Sending HTTP headers to subgraphs"}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["The router's config file is set to propagate Authorization headers.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The router sends the Authorization header to its subgraphs with every request."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"over-to-the-subgraph",children:"Over to the subgraph"}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:["Subgraph attempts to authenticate the user.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the authentication is successful, then the subgraph puts together an object containing user information and makes it available in its context."}),"\n",(0,t.jsx)(n.li,{children:"If the authentication fails, subgraph returns an Authorization Error to the router."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"The subgraph resolves the operations using authenticated user info and sends data back to the router."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"back-to-the-router",children:"Back to the Router"}),"\n",(0,t.jsxs)(n.ol,{start:"6",children:["\n",(0,t.jsxs)(n.li,{children:["The subgraph sends back the requested data to the router, and the router continues with its query plan, eventually combining all those responses into a single JSON object.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The router sends the final JSON object back to the client."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"practice-2",children:"Practice"}),"\n",(0,t.jsxs)(n.p,{children:["Which of the following options can be included as part of a router's ",(0,t.jsx)(n.code,{children:"config"})," file?"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Customizing which headers the router can receive and where to send them"}),"\n",(0,t.jsx)(n.li,{children:"Configuring CORS for permitted request origins"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["HTTP header called ",(0,t.jsx)(n.strong,{children:"Authorization"})," contains the current user's auth token."]}),"\n",(0,t.jsx)(n.li,{children:"The router can be customized with a configuration file, to pass along HTTP headers to its subgraphs."}),"\n",(0,t.jsxs)(n.li,{children:["The router passes the user's auth token to the subgraph, which checks whether or not the token is valid for login.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the login is unsuccessful, the subgraph throws an ",(0,t.jsx)(n.code,{children:"AuthenticationError"})," and sends it back to the router."]}),"\n",(0,t.jsxs)(n.li,{children:["If the login is successful, the subgraph adds the current user's information to its ",(0,t.jsx)(n.code,{children:"contextValue"})," object, which is accessible by its resolvers for field-level authorization."]}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"configuring-the-router",children:"Configuring the router"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/05-configuring-the-router",children:"Configuring the router"})}),"\n",(0,t.jsx)(n.h4,{id:"practice-3",children:"Practice"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"config.yaml"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'headers:\n  all:\n    request:\n      - propagate:\n          named: "airlock-cookie"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the above ",(0,t.jsx)(n.strong,{children:"config.yaml"})," file, what does the ",(0,t.jsx)(n.code,{children:"propagate"})," key tell the router to do?"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Send the 'airlock-cookie' header to all subgraphs."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To pass down authorization headers from the router to its subgraphs, we need to set up the router's config file.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In the config file, we can set the ",(0,t.jsx)(n.code,{children:"headers"})," property and use the ",(0,t.jsx)(n.code,{children:"propagate"})," property."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["A subgraph can access the authorization (and other request) headers from the router through its ",(0,t.jsx)(n.code,{children:"ApolloServer"})," constructor ",(0,t.jsx)(n.code,{children:"context"})," property."]}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"subgraph-planning",children:"Subgraph planning"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/06-subgraph-planning",children:"Subgraph planning"})}),"\n",(0,t.jsx)(n.h3,{id:"planning-and-preparation",children:"Planning and preparation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Starting with a plan of your end goal for your supergraph architecture is helpful in understanding where to start first."}),"\n",(0,t.jsx)(n.li,{children:"Follow incremental adoption: starting with one subgraph and take small action steps, one at a time."}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Identify entities"}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["An ",(0,t.jsx)(n.strong,{children:"entity"})," is an object type with fields split between multiple subgraphs."]}),"\n",(0,t.jsx)(n.li,{children:"Each subgraph is responsible for resolving only the fields it contributes to an entity, and each entity instance is uniquely identifiable with a primary key field."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"which-of-the-following-types-should-be-marked-as-an-entity-in-the-schema",children:"Which of the following types should be marked as an entity in the schema?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Booking"}),"\n",(0,t.jsx)(n.li,{children:"Listing"}),"\n",(0,t.jsx)(n.li,{children:"Host"}),"\n",(0,t.jsx)(n.li,{children:"Review"}),"\n",(0,t.jsx)(n.li,{children:"Guest"}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Identify subgraphs"}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"accounts"}),"\n",(0,t.jsx)(n.li,{children:"listings"}),"\n",(0,t.jsx)(n.li,{children:"bookings"}),"\n",(0,t.jsx)(n.li,{children:"reviews"}),"\n",(0,t.jsx)(n.li,{children:"payments"}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsx)(n.li,{children:"Decide which entities to migrate first"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"define-entities",children:"Define entities"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/07-define-entities",children:"Define entities"})}),"\n",(0,t.jsx)(n.p,{children:"Defining entities is an important step in migrating to a federated architecture. It enables everyone to explore the schema and contribute to it."}),"\n",(0,t.jsx)(n.h2,{id:"a-stub-subgraph",children:"A Stub subgraph"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/08-stub-subgraph",children:"A Stub subgraph"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stub subgraph"}),": an empty subgraph equipped with the bare minimum needed to get it up and running.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It enables us to start with a clean state, set up any CI/CD pipelines with schema checks and approach schema migration incrementally."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"practice-4",children:"Practice"}),"\n",(0,t.jsxs)(n.p,{children:["Which of the following does ",(0,t.jsx)(n.code,{children:"rover dev"})," not do?"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Creates a new stub subgraph"}),"\n",(0,t.jsx)(n.li,{children:"Pushes your changes to your supergraph on GraphOS"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"rover dev"})," helps us with local supergraph development by composing our subgraph schemas locally and spinning up a router."]})}),"\n",(0,t.jsxs)(n.h2,{id:"using-override-to-migrate-fields",children:["Using ",(0,t.jsx)(n.code,{children:"@override"})," to migrate fields"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/09-using-override",children:["Using ",(0,t.jsx)(n.code,{children:"@override"})," to migrate fields"]})}),"\n",(0,t.jsxs)(n.h3,{id:"the-override-directive",children:["The ",(0,t.jsx)(n.code,{children:"@override"})," directive"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To migrate fields safely from one subgraph to another, we use the ",(0,t.jsx)(n.code,{children:"@override"})," directive."]}),"\n",(0,t.jsxs)(n.li,{children:["We can apply ",(0,t.jsx)(n.code,{children:"@override"})," to fields of an entity and fields of root operation types (such as ",(0,t.jsx)(n.code,{children:"Query"})," and ",(0,t.jsx)(n.code,{children:"Mutation"}),")","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["It tells the router that a particular field is now resolved by the subgraph that applies ",(0,t.jsx)(n.code,{children:"@override"}),", instead of another subgraph where the field is also defined."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"@override"})," directive takes in an argument called ",(0,t.jsx)(n.code,{children:"from"}),", which will be the name of the subgraph that originally defined the field."]}),"\n",(0,t.jsxs)(n.li,{children:["Example in ",(0,t.jsx)(n.strong,{children:"subgraph-accounts/schema.graphql"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'type Query {\n  user(id: ID!): User @override(from: "monolith")\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"monolith"})," subgraph schema can stay the same, but the router won't call on it anymore when the ",(0,t.jsx)(n.code,{children:"user"})," field is requested."]})}),"\n",(0,t.jsxs)(n.h3,{id:"incremental-migration-with-progressive-override",children:["Incremental migration with progressive ",(0,t.jsx)(n.code,{children:"@override"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In production environments, we probably want to take it slower, monitoring performance and issues as we make these changes."}),"\n",(0,t.jsxs)(n.li,{children:["To do this, we can add another argument to the ",(0,t.jsx)(n.code,{children:"@override"})," directive: ",(0,t.jsx)(n.code,{children:"label"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["This argument takes in a string value starting with ",(0,t.jsx)(n.code,{children:"percent"})," followed by a number in parentheses."]}),"\n",(0,t.jsx)(n.li,{children:"The number represents the percentage of traffic for the field that's resolved by this subgraph."}),"\n",(0,t.jsxs)(n.li,{children:["The remaining percentage is resolved by the other (",(0,t.jsx)(n.code,{children:"from"}),") subgraph."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Example in ",(0,t.jsx)(n.strong,{children:"subgraph-accounts/schema.graphql"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'type Query {\n  user(id: ID!): User @override(from: "monolith", label: "percent(25)")\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"monolith"})," subgraph schema still stays the same, but now the router will route its requests to the ",(0,t.jsx)(n.code,{children:"monolith"})," subgraph 75% of the time, and the ",(0,t.jsx)(n.code,{children:"accounts"})," subgraph 25% of the time for the ",(0,t.jsx)(n.code,{children:"Query.user"})," field."]})}),"\n",(0,t.jsx)(n.h4,{id:"practice-5",children:"Practice"}),"\n",(0,t.jsxs)(n.p,{children:["Which of the following is true about the ",(0,t.jsx)(n.code,{children:"@override"})," directive?"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It can be applied on field in an object type."}),"\n",(0,t.jsxs)(n.li,{children:["It takes an argument called ",(0,t.jsx)(n.code,{children:"from"})," that indicates the subgraph the field is overriding."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"@override"})," directive can be applied to fields of an entity and fields of root operation types to indicate which subgraph should have the responsibility of resolving it."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"@override"})," directive accepts an argument called ",(0,t.jsx)(n.code,{children:"from"}),", which specifies the name of the subgraph that originally defined the field (and which is being overridden)."]}),"\n",(0,t.jsxs)(n.li,{children:["With progressive override, we can provide the ",(0,t.jsx)(n.code,{children:"@override"})," directive with an additional argument, ",(0,t.jsx)(n.code,{children:"label"}),". This specifies the percentage of time the router should call upon the subgraph to resolve the field."]}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"implementing-resolvers",children:"Implementing resolvers"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/10-implementing-resolvers",children:"Implementing resolvers"})}),"\n",(0,t.jsx)(n.h4,{id:"code-challenge",children:"Code Challenge"}),"\n",(0,t.jsx)(n.p,{children:"Refer to this schema for the question below:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'interface Book {\n  isbn: ID!\n  title: String!\n  genre: String!\n}\n\ntype PictureBook implements Book @key(fields: "isbn") {\n  isbn: ID!\n  title: String!\n  genre: String!\n  numberOfPictures: Int\n  isInColor: Boolean\n}\n\ntype YoungAdultNovel implements Book {\n  isbn: ID!\n  title: String!\n  genre: String!\n  wordCount: Int\n  numberOfChapters: Int\n}\n\ntype LibraryMember @key(fields: "id") {\n  id: ID! @external\n  faveBook: Book!\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Write a resolver for LibraryMember.faveBook to return a representation of the entity. The underlying object for each book contains a ",(0,t.jsx)(n.code,{children:"hasPictures"})," property, which you can use to determine if it's a ",(0,t.jsx)(n.code,{children:"PictureBook"})," or a ",(0,t.jsx)(n.code,{children:"YoungAdultNovel"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const resolvers = {\n  LibraryMember: {\n    faveBook: (book) => {\n      const type = book.hasPictures ? "PictureBook" : "YoungAdultNovel";\n      return { __typename: type, isbn: book.isbn };\n    },\n  },\n};\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Any subgraph that contributes fields to an entity needs to define a ",(0,t.jsx)(n.code,{children:"__resolveReference"})," resolver function for that entity."]}),"\n",(0,t.jsxs)(n.li,{children:["An entity representation is an object that includes the entity's ",(0,t.jsx)(n.code,{children:"__typename"})," and ",(0,t.jsx)(n.code,{children:"@key"})," fields."]}),"\n",(0,t.jsxs)(n.li,{children:["An interface needs a ",(0,t.jsx)(n.code,{children:"__resolveType"})," resolver."]}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"finishing-up-the-subgraph",children:"Finishing up the subgraph"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.apollographql.com/tutorials/voyage-part2/11-finishing-up-the-subgraph",children:"Finishing up the subgraph"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"The router configuration file takes an option to define a CORS policy, which allows the origins you specify to communicate with your router."})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(6540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);